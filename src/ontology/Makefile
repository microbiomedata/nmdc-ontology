# ----------------------------------------
# Makefile for nmdco
# Generated using ontology-development-kit
# ODK Version: v1.2.27
# ----------------------------------------
# IMPORTANT: DO NOT EDIT THIS FILE. To override default make goals, use nmdco.Makefile instead


# ----------------------------------------
# More information: https://github.com/INCATools/ontology-development-kit/


# ----------------------------------------
# Standard Constants
# ----------------------------------------
# these can be overwritten on the command line

URIBASE=                    http://purl.obolibrary.org/obo
ONT=                        nmdco
ONTBASE=                    $(URIBASE)/$(ONT)
EDIT_FORMAT=                owl
SRC =                       $(ONT)-edit.$(EDIT_FORMAT)
CATALOG=                    catalog-v001.xml
ROBOT=                      robot --catalog $(CATALOG)
RELEASEDIR=                 ../..
REPORTDIR=                  reports
TEMPLATEDIR=                ../templates
TMPDIR=                     tmp
SCRIPTSDIR=                 ../scripts
SPARQLDIR =                 ../sparql
IMPORTS_DIR =             	imports
REPORT_FAIL_ON =            None
REPORT_LABEL =              -l true
REPORT_PROFILE_OPTS =       
OBO_FORMAT_OPTIONS =        
SPARQL_VALIDATION_CHECKS =   equivalent-classes owldef-self-reference
SPARQL_EXPORTS =             basic-report class-count-by-prefix edges xrefs obsoletes synonyms
ODK_VERSION_MAKEFILE =      v1.2.27

TODAY ?=                    $(shell date +%Y-%m-%d)
OBODATE ?=                  $(shell date +'%d:%m:%Y %H:%M')
VERSION=                    $(TODAY)
ANNOTATION_PROPERTIES=rdfs:label IAO:0000115 
ANNOTATE_ONTOLOGY_VERSION = annotate -V $(ONTBASE)/releases/$(VERSION)/$@ --annotation owl:versionInfo $(VERSION)
OTHER_SRC =                 $(IMPORTS_DIR)/po_import.owl $(IMPORTS_DIR)/envo_import.owl $(IMPORTS_DIR)/ro_import.owl 
ONTOLOGYTERMS =             $(TMPDIR)/ontologyterms.txt

FORMATS = $(sort  owl)
FORMATS_INCL_TSV = $(sort $(FORMATS) tsv)
RELEASE_ARTEFACTS = $(sort $(ONT)-full $(ONT)-non-classified $(ONT)-relation-graph)

# ----------------------------------------
# Top-level targets
# ----------------------------------------

.PHONY: .FORCE all all_imports all_subsets test refresh-imports refresh-% release

all: all_imports all_main all_subsets

MAIN_PRODUCTS = $(sort $(foreach r,$(RELEASE_ARTEFACTS), $(r)) $(ONT))
MAIN_GZIPPED = 
MAIN_FILES = $(foreach n,$(MAIN_PRODUCTS), $(foreach f,$(FORMATS), $(n).$(f))) $(MAIN_GZIPPED)

.PHONY: all_main
all_main: $(MAIN_FILES)

# ----------------------------------------
# Release Management
# ----------------------------------------

CLEANFILES=$(MAIN_FILES) $(SRCMERGED)
# This should be executed by the release manager whenever time comes to make a release.
# It will ensure that all assets/files are fresh, and will copy to release folder

release: $(ONT).owl $(ONT)-relation-graph.owl
	cp $^ $(RELEASEDIR)



# ----------------------------------------
# Import modules
# ----------------------------------------
# Most ontologies are modularly constructed using portions of other ontologies
# These live in the imports/ folder

IMPORTS =  ro envo po
IMPORT_ROOTS = $(patsubst %, imports/%_import, $(IMPORTS))
IMPORT_OWL_FILES = $(foreach n,$(IMPORT_ROOTS), $(n).owl)
IMPORT_FILES = $(IMPORT_OWL_FILES)

all_imports: $(IMPORT_FILES)

$(SRCMERGED): $(SRC)
	$(ROBOT) remove --input $< --select imports --trim false \
		merge  $(patsubst %, -i %, $(OTHER_SRC)) -o $@

$(PRESEED): $(SRCMERGED)
	$(ROBOT) query -f csv -i $< --query ../sparql/terms.sparql $@.tmp &&\
	cat $@.tmp | sort | uniq >  $@

ALLSEED = $(PRESEED)
$(IMPORTSEED):  $(ALLSEED) 
	if [ $(IMP) = true ]; then cat $(ALLSEED) | sort | uniq > $@; fi


# -- Generate Import Modules --
imports/%_import.owl: mirror/%.owl #imports/%_terms_combined.txt
	$(ROBOT) annotate --input $< \
	  --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@

.PRECIOUS: imports/%_import.owl


refresh-imports:
	make all_imports -B

refresh-%:
	make imports/$*_import.owl -B


# ----------------------------------------
# Mirroring upstream ontologies
# ----------------------------------------
#

IMP=true # Global parameter to bypass import generation
MIR=true # Global parameter to bypass mirror generation
IMP_LARGE=true # Global parameter to bypass handling of large imports


## ONTOLOGY: ro
## Copy is re-downloaded whenever source changes
mirror/ro.trigger: $(SRC)
mirror/po.trigger: $(SRC)
mirror/envo.trigger: $(SRC)

mirror/ro.owl: mirror/ro.trigger
	if [ $(MIR) = true ] && [ $(IMP) = true ]; then $(ROBOT) convert -I $(URIBASE)/ro.owl -o $@.tmp.owl && mv $@.tmp.owl $@; fi

mirror/po.owl: mirror/po.trigger
	if [ $(MIR) = true ] && [ $(IMP) = true ]; then $(ROBOT) convert -I $(URIBASE)/po.owl -o $@.tmp.owl && mv $@.tmp.owl $@; fi

mirror/envo.owl: mirror/envo.trigger
	if [ $(MIR) = true ] && [ $(IMP) = true ]; then $(ROBOT) convert -I $(URIBASE)/envo.owl -o $@.tmp.owl && mv $@.tmp.owl $@; fi
.PRECIOUS: mirror/%.owl


# ----------------------------------------
# Release artefacts: main release artefacts
# ----------------------------------------

$(ONT).owl: $(ONT)-full.owl
	$(ROBOT) annotate --input $< --ontology-iri $(URIBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) \
		convert -o $@.tmp.owl && mv $@.tmp.owl $@

# -----------------------------------------------------
# Release artefacts: variants (base, full, simple, etc)
# -----------------------------------------------------

$(ONTOLOGYTERMS): $(SRC) $(OTHER_SRC)
	touch $(ONTOLOGYTERMS) && \
	$(ROBOT) query --use-graphs true -f csv -i $< --query ../sparql/nmdco_terms.sparql $@


# Full: The full artefacts with imports merged, reasoned
$(ONT)-full.owl: $(SRC) $(OTHER_SRC)
	$(ROBOT) merge --input $< \
		reason --reasoner ELK --equivalent-classes-allowed all --exclude-tautologies structural \
		relax \
		reduce -r ELK \
		annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@


# foo-non-classified: (edit->imports-merged)
$(ONT)-non-classified.owl: $(SRC) $(OTHER_SRC)
	$(ROBOT) merge --input $< \
		annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@


.PHONY: update_repo
update_repo:
	sh $(SCRIPTSDIR)/update_repo.sh

## -- cusotom targets -- ##
.PHONY: test-query

$(ONT)-merged.owl: $(SRC) $(OTHER_SRC)
# merge imports into single owl file
	$(ROBOT) merge --input $< $(patsubst %, --input %, $(OTHER_SRC)) \
	  annotate --ontology-iri $(ONTBASE)/$@ \
	  $(ANNOTATE_ONTOLOGY_VERSION) \
	  --output $@.tmp.owl
# remove obsolete classes
	robot remove --input $@.tmp.owl \
	  --select "owl:deprecated='true'^^xsd:boolean" \
	  --output $@
# clean up
	rm -f $@.tmp.owl


$(ONT)-merged.ttl: $(ONT)-merged.owl
# convert merged owl file to ttl
	$(ROBOT) annotate --ontology-iri $(ONTBASE)/$@ --input $< \
	         convert --output $@

# ----------------------------------------
# Relation graph
# ----------------------------------------

$(ONT)-merged-labels.ttl: $(ONT)-merged.ttl
# create an ontology of just the labels in the merged ontology
# this is needed so that we can easily view the ontology in protege
	$(ROBOT) query --format ttl -i $< --query ../sparql/all-labels.sparql $@


$(ONT)-relation-graph.ttl: $(ONT)-merged.ttl $(ONT)-merged-labels.ttl
# build relation-graph from nmdc-merged.ttl file
# for relation-graph see https://github.com/balhoff/relation-graph	
# note, you may need to increase Java memory: export JAVA_OPTS=-Xmx16G
	relation-graph --ontology-file $< \
	  --reflexive-subclasses false \
	  --equivalence-as-subclass true \
	  --non-redundant-output-file $(ONT)-nonredundant.ttl \
	  --redundant-output-file $(ONT)-redundant.ttl \
	  --mode rdf
# merge in nmdco-merged for annotations
	$(ROBOT) merge \
	  --input $(word 2, $^) \
	  --input $(ONT)-nonredundant.ttl \
	  annotate --ontology-iri $(ONTBASE)/$@ \
	  $(ANNOTATE_ONTOLOGY_VERSION) \
	  --output $@
# copy relation-graph to release directory
	cp $@ $(RELEASEDIR)


$(ONT)-relation-graph.owl: $(ONT)-relation-graph.ttl
# convert file to owl
	$(ROBOT) annotate --ontology-iri $(ONTBASE)/$@ --input $< \
	         convert --output $@

# ----------------------------------------
# Subsets
# ----------------------------------------
.PHONEY: test-query test-subsets subsets

SUBSETS := \
	subsets/astronomical-body-parts.tsv \
	subsets/astronomical-body-parts-and-manufactured-products.tsv \
	subsets/non-terrestrial-biomes.tsv \
	subsets/terrestrial-biomes.tsv \
	subsets/soil-environmental-materials.tsv \
	subsets/manufactured-products.tsv


test-query: $(ONT)-relation-graph.owl .FORCE
# a simple query to very that I can run a query
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/nmdco-test.sparql temp.tsv

test-subsets: $(SUBSETS) .FORCE
# test creating all subsets

subsets:
# create all subset files

subsets/astronomical-body-parts.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/astronomical-body-parts.sparql $@

subsets/astronomical-body-parts-and-manufactured-products.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/astronomical-body-parts-and-manufactured-products.sparql $@

subsets/non-terrestrial-biomes.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/non-terrestrial-biomes.sparql $@

subsets/terrestrial-biomes.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/terrestrial-biomes.sparql $@

subsets/soil-environmental-materials.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/soil-environmental-materials.sparql $@

subsets/manufactured-products.tsv: $(ONT)-relation-graph.owl
	$(ROBOT) query \
	  --input $< \
	  --query ../sparql/manufactured-products.sparql $@



include nmdco.Makefile
